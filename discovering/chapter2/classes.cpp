#include <cmath>
#include <iostream>

class complex {
public:
  double r = 0.0;
  double i = 0.0;

  complex() = default;
  explicit complex(double real, double imaginary = 0.0) : r(real), i(imaginary) {}

  // copy-constructor = the generated one would be better
  complex(const complex &c) : r(c.r), i(c.i) {}

  // assignment operator = also generated by the compiler
  complex &operator=(const complex &src) {
    r = src.r;
    i = src.i;
    return *this;
  }
  // explicit double assignment overload to avoid construction of extra objects
  complex &operator=(double nr) {
    r = nr;
    i = 0.0;
    return *this;
  }

  auto real() -> double & { return r; }
  auto imaginary() -> double & { return i; }

  friend std::ostream &operator<<(std::ostream &stream, const complex &c) {
    stream << '(' << c.r << ", " << c.i << ')';
    return stream;
  }

  // Addition operator
  complex operator+(const complex &c2) const {
    return complex(r + c2.r, i + c2.i);
  }
  complex operator+(double r2) const { return complex(r + r2, i); }

  friend double &real(complex &c);
  friend const double &real(const complex &c);
};

// accessor functions
inline double &real(complex &c) { return c.real(); }
inline const double &real(const complex &c) { return c.r; }

double inline complex_abs(complex c) {
  return std::sqrt(c.real() * c.real() + c.imaginary() * c.imaginary());
}

auto main() -> int {

  complex z, c;
  z.r = 3.5;
  z.i = 2;
  c.r = 2;
  c.i = -3.5;
  std::cout << "z is " << z << std::endl;
  std::cout << "c is " << c << std::endl;

  std::cout << z.imaginary() << std::endl;

  complex a1;
  complex a2{};
  complex a3(3);
  complex a4(3, 4);

  std::cout << a1 << ' ' << a2 << ' ' << a3 << ' ' << a4 << std::endl;

  complex b1(a4);
  complex b2{a4};

  std::cout << b1 << ' ' << b2 << std::endl;

  // implicit constructor - to disable this mark the constructor "explicit"
  // complex c1 = 3.1;

  complex c1{3.1};
  std::cout << c1 << std::endl;

  // implicit conversion to complex type here:
  std::cout << "|7| = " << complex_abs(complex{7.0}) << std::endl;

  complex c2;
  c2 = c1;

  std::cout << c2 << std::endl;

  real(c2) += 2.0;
  std::cout << c2 << std::endl;

  double r2 = real(complex(3, 7)) * 2.0;
  std::cout << r2 << std::endl;

  // using the operators
  std::cout << c2 + complex(3, 0) << std::endl;
  std::cout << c2 + 3 << std::endl;

  return 0;
}
